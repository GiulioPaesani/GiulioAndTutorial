"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Song_metadata, _Song_member, _Song_playlist;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Song = void 0;
const Playlist_1 = require("./Playlist");
const __1 = require("..");
// TODO: Clean parameters on the next major version.
/**
 * Class representing a song.
 *
 * <info>If {@link Song} is added from a YouTube {@link SearchResult} or {@link Playlist},
 * some info will be missing to save your resources. It will be filled when emitting {@link DisTube#playSong} event.
 *
 * Missing info: {@link Song#likes}, {@link Song#dislikes}, {@link Song#streamURL},
 * {@link Song#related}, {@link Song#chapters}, {@link Song#age_restricted}</info>
 * @template T - The type for the metadata (if any) of the song
 */
class Song {
    constructor(info, options = {}, src = "youtube", meta) {
        _Song_metadata.set(this, void 0);
        _Song_member.set(this, void 0);
        _Song_playlist.set(this, void 0);
        if ((0, __1.isMemberInstance)(options)) {
            process.emitWarning("Passing GuildMember for DisTube#Song() is deprecated, read the docs for more.", "DeprecationWarning");
            return new Song(info, { member: options, source: src, metadata: meta });
        }
        const { member, source, metadata } = { source: "youtube", ...options };
        if (typeof source !== "string" ||
            (info.src && typeof info.src !== "string")) {
            throw new __1.DisTubeError("INVALID_TYPE", "string", source, "source");
        }
        /**
         * The source of the song
         * @type {string}
         */
        this.source = (info?.src || source).toLowerCase();
        /**
         * Optional metadata that can be used to identify the song.
         * @type {T}
         */
        this.metadata = metadata;
        this.member = member;
        if (this.source === "youtube") {
            this._patchYouTube(info);
        }
        else {
            this._patchOther(info);
        }
    }
    _patchYouTube(i) {
        // FIXME
        const info = i;
        if (info.full === true) {
            /**
             * Stream formats (Available if the song is from YouTube and playing)
             * @type {ytdl.videoFormat[]?}
             * @private
             */
            this.formats = info.formats;
            // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
            const err = require("@distube/ytdl-core/lib/utils").playError(info.player_response, [
                "UNPLAYABLE",
                "LIVE_STREAM_OFFLINE",
                "LOGIN_REQUIRED",
            ]);
            if (err)
                throw err;
            if (!info.formats?.length)
                throw new __1.DisTubeError("UNAVAILABLE_VIDEO");
        }
        const details = info.videoDetails || info;
        /**
         * YouTube video id
         * @type {string?}
         */
        this.id = details.videoId || details.id;
        /**
         * Song name.
         * @type {string?}
         */
        this.name = details.title || details.name;
        /**
         * Indicates if the video is an active live.
         * @type {boolean}
         */
        this.isLive = !!details.isLive;
        /**
         * Song duration.
         * @type {number}
         */
        this.duration = this.isLive ? 0 : (0, __1.toSecond)(details.lengthSeconds || details.length_seconds || details.duration);
        /**
         * Formatted duration string (`hh:mm:ss`, `mm:ss` or `Live`).
         * @type {string?}
         */
        this.formattedDuration = this.isLive ? "Live" : (0, __1.formatDuration)(this.duration);
        /**
         * Song URL.
         * @type {string}
         */
        this.url = `https://www.youtube.com/watch?v=${this.id}`;
        /**
         * Stream / Download URL (Available if the song is playing)
         * @type {string?}
         */
        this.streamURL = undefined;
        /**
         * Song thumbnail.
         * @type {string?}
         */
        this.thumbnail =
            details.thumbnails?.sort((a, b) => b.width - a.width)?.[0]?.url ||
                details.thumbnail?.url ||
                details.thumbnail;
        /**
         * Related songs (without {@link Song#related} properties)
         * @type {Song[]}
         */
        this.related = info?.related_videos || details.related || [];
        if (!Array.isArray(this.related))
            throw new __1.DisTubeError("INVALID_TYPE", "Array", this.related, "Song#related");
        this.related = this.related.map((v) => new Song(v, { source: this.source, metadata: this.metadata }));
        /**
         * Song views count
         * @type {number}
         */
        this.views = (0, __1.parseNumber)(details.viewCount || details.view_count || details.views);
        /**
         * Song like count
         * @type {number}
         */
        this.likes = (0, __1.parseNumber)(details.likes);
        /**
         * Song dislike count
         * @type {number}
         */
        this.dislikes = (0, __1.parseNumber)(details.dislikes);
        /**
         * Song uploader
         * @type {Object}
         * @prop {string?} name Uploader name
         * @prop {string?} url Uploader url
         */
        this.uploader = {
            name: info.uploader?.name || details.author?.name,
            url: info.uploader?.url || details.author?.channel_url || details.author?.url,
        };
        /**
         * Whether or not an age-restricted content
         * @type {boolean}
         */
        this.age_restricted = !!details.age_restricted;
        /**
         * @typedef {Object} Chapter
         * @prop {string} title Chapter title
         * @prop {number} start_time Chapter start time in seconds
         */
        /**
         * Chapters information (YouTube only)
         * @type {Chapter[]}
         */
        this.chapters = details.chapters || [];
        /**
         * Song repost count
         * @type {number}
         */
        this.reposts = 0;
    }
    /**
     * Patch data from other source
     * @param {OtherSongInfo} info Video info
     * @private
     */
    _patchOther(info) {
        this.id = info.id;
        this.name = info.title || info.name;
        this.isLive = Boolean(info.is_live || info.isLive);
        this.duration = this.isLive ? 0 : (0, __1.toSecond)(info._duration_raw || info.duration);
        this.formattedDuration = this.isLive ? "Live" : (0, __1.formatDuration)(this.duration);
        this.url = info.webpage_url || info.url;
        this.thumbnail = info.thumbnail;
        this.related = info.related || [];
        if (!Array.isArray(this.related))
            throw new __1.DisTubeError("INVALID_TYPE", "Array", this.related, "Song#related");
        this.related = this.related.map(i => new Song(i, { source: this.source, metadata: this.metadata }));
        this.views = (0, __1.parseNumber)(info.view_count || info.views);
        this.likes = (0, __1.parseNumber)(info.like_count || info.likes);
        this.dislikes = (0, __1.parseNumber)(info.dislike_count || info.dislikes);
        this.reposts = (0, __1.parseNumber)(info.repost_count || info.reposts);
        if (typeof info.uploader === "string") {
            this.uploader = {
                name: info.uploader,
                url: info.uploader_url,
            };
        }
        else {
            this.uploader = {
                name: info.uploader?.name,
                url: info.uploader?.url,
            };
        }
        this.age_restricted = info.age_restricted || (!!info.age_limit && (0, __1.parseNumber)(info.age_limit) >= 18);
        this.chapters = info.chapters || [];
    }
    /**
     * The playlist added this song
     * @type {Playlist?}
     */
    get playlist() {
        return __classPrivateFieldGet(this, _Song_playlist, "f");
    }
    set playlist(playlist) {
        if (!(playlist instanceof Playlist_1.Playlist))
            throw new __1.DisTubeError("INVALID_TYPE", "Playlist", playlist, "Song#playlist");
        __classPrivateFieldSet(this, _Song_playlist, playlist, "f");
        this.member = playlist.member;
    }
    /**
     * User requested.
     * @type {Discord.GuildMember?}
     */
    get member() {
        return __classPrivateFieldGet(this, _Song_member, "f");
    }
    set member(member) {
        if (!member)
            return;
        __classPrivateFieldSet(this, _Song_member, member, "f");
    }
    /**
     * User requested.
     * @type {Discord.User?}
     */
    get user() {
        return this.member?.user;
    }
    get metadata() {
        return __classPrivateFieldGet(this, _Song_metadata, "f");
    }
    set metadata(metadata) {
        __classPrivateFieldSet(this, _Song_metadata, metadata, "f");
    }
}
exports.Song = Song;
_Song_metadata = new WeakMap(), _Song_member = new WeakMap(), _Song_playlist = new WeakMap();
//# sourceMappingURL=Song.js.map