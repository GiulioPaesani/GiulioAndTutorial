"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Playlist_metadata, _Playlist_member;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Playlist = void 0;
const __1 = require("..");
// TODO: Remove ! on the next major version
/**
 * Class representing a playlist.
 * @prop {string} source Playlist source
 * @template T - The type for the metadata (if any) of the playlist
 */
class Playlist {
    constructor(playlist, options = {}, props, meta) {
        _Playlist_metadata.set(this, void 0);
        _Playlist_member.set(this, void 0);
        if ((0, __1.isMemberInstance)(options)) {
            process.emitWarning("Passing GuildMember for DisTube#Playlist() is deprecated, read the docs for more.", "DeprecationWarning");
            return new Playlist(playlist, { member: options, properties: props, metadata: meta });
        }
        const { member, properties, metadata } = options;
        if (typeof playlist !== "object") {
            throw new __1.DisTubeError("INVALID_TYPE", ["Array<Song>", "object"], playlist, "playlist");
        }
        if (typeof properties !== "undefined" && !(0, __1.isRecord)(properties)) {
            throw new __1.DisTubeError("INVALID_TYPE", "object", properties, "properties");
        }
        // FIXME
        const info = playlist;
        /**
         * The source of the playlist
         * @type {string}
         */
        this.source = (info.source || properties?.source || "youtube").toLowerCase();
        /**
         * Playlist songs.
         * @type {Array<Song>}
         */
        this.songs = Array.isArray(info) ? info : info.items || info.songs;
        if (!Array.isArray(this.songs) || !this.songs.length) {
            throw new __1.DisTubeError("EMPTY_PLAYLIST");
        }
        this.songs.map(s => s.constructor.name === "Song" && (s.playlist = this));
        this.member = member || info.member || undefined;
        /**
         * Playlist name.
         * @type {string}
         */
        this.name =
            info.name ||
                info.title ||
                (this.songs[0].name
                    ? `${this.songs[0].name} and ${this.songs.length - 1} more songs.`
                    : `${this.songs.length} songs playlist`);
        /**
         * Playlist URL.
         * @type {string}
         */
        this.url = info.url || info.webpage_url;
        /**
         * Playlist thumbnail.
         * @type {string?}
         */
        this.thumbnail = info.thumbnail?.url || info.thumbnail || this.songs[0].thumbnail;
        if (properties)
            for (const [key, value] of Object.entries(properties))
                this[key] = value;
        this.metadata = metadata;
    }
    /**
     * Playlist duration in second.
     * @type {number}
     */
    get duration() {
        return this.songs?.reduce((prev, next) => prev + (next.duration || 0), 0) || 0;
    }
    /**
     * Formatted duration string `hh:mm:ss`.
     * @type {string}
     */
    get formattedDuration() {
        return (0, __1.formatDuration)(this.duration);
    }
    /**
     * User requested.
     * @type {Discord.GuildMember?}
     */
    get member() {
        return __classPrivateFieldGet(this, _Playlist_member, "f");
    }
    set member(member) {
        if (!member)
            return;
        __classPrivateFieldSet(this, _Playlist_member, member, "f");
        this.songs.map(s => s.constructor.name === "Song" && (s.member = this.member));
    }
    /**
     * User requested.
     * @type {Discord.User?}
     */
    get user() {
        return this.member?.user;
    }
    /**
     * Optional metadata that can be used to identify the playlist.
     * @type {T}
     */
    get metadata() {
        return __classPrivateFieldGet(this, _Playlist_metadata, "f");
    }
    set metadata(metadata) {
        __classPrivateFieldSet(this, _Playlist_metadata, metadata, "f");
        this.songs.map(s => s.constructor.name === "Song" && (s.metadata = metadata));
    }
}
exports.Playlist = Playlist;
_Playlist_metadata = new WeakMap(), _Playlist_member = new WeakMap();
//# sourceMappingURL=Playlist.js.map