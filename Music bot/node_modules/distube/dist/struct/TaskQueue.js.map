{"version":3,"file":"TaskQueue.js","sourceRoot":"","sources":["../../src/struct/TaskQueue.ts"],"names":[],"mappings":";;;;;;;;;AAAA,MAAM,IAAI;IAIR,YAAY,WAAoB;QAC9B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAO,GAAG,CAAC,EAAE;YACrC,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC;QACrB,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAED;;;GAGG;AACH,MAAa,SAAS;IAAtB;QACE;;;;WAIG;QACH,2BAAiB,EAAE,EAAC;IAmCtB,CAAC;IAjCC;;;;OAIG;IACI,OAAO,CAAC,WAAW,GAAG,KAAK;QAChC,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,uBAAA,IAAI,wBAAO,CAAC,uBAAA,IAAI,wBAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC9F,uBAAA,IAAI,wBAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;QACxC,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,uBAAA,IAAI,wBAAO,CAAC,KAAK,EAAE,EAAE,OAAO,EAAE,CAAC;IACjC,CAAC;IAED;;;OAGG;IACH,IAAW,SAAS;QAClB,OAAO,uBAAA,IAAI,wBAAO,CAAC,MAAM,CAAC;IAC5B,CAAC;IAED;;;OAGG;IACH,IAAW,cAAc;QACvB,OAAO,CAAC,CAAC,uBAAA,IAAI,wBAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;IAChD,CAAC;CACF;AAzCD,8BAyCC","sourcesContent":["class Task {\n  resolve!: () => void;\n  promise: Promise<void>;\n  resolveInfo: boolean;\n  constructor(resolveInfo: boolean) {\n    this.resolveInfo = resolveInfo;\n    this.promise = new Promise<void>(res => {\n      this.resolve = res;\n    });\n  }\n}\n\n/**\n * Task queuing system\n * @private\n */\nexport class TaskQueue {\n  /**\n   * The task array\n   * @type {Task[]}\n   * @private\n   */\n  #tasks: Task[] = [];\n\n  /**\n   * Waits for last task finished and queues a new task\n   * @param {boolean} [resolveInfo=false] Whether the task is a resolving info task\n   * @returns {Promise<void>}\n   */\n  public queuing(resolveInfo = false): Promise<void> {\n    const next = this.remaining ? this.#tasks[this.#tasks.length - 1].promise : Promise.resolve();\n    this.#tasks.push(new Task(resolveInfo));\n    return next;\n  }\n\n  /**\n   * Removes the finished task and processes the next task\n   */\n  public resolve(): void {\n    this.#tasks.shift()?.resolve();\n  }\n\n  /**\n   * The remaining number of tasks\n   * @type {number}\n   */\n  public get remaining(): number {\n    return this.#tasks.length;\n  }\n\n  /**\n   * Whether or not having a resolving info task\n   * @type {boolean}\n   */\n  public get hasResolveTask(): boolean {\n    return !!this.#tasks.find(t => t.resolveInfo);\n  }\n}\n"]}