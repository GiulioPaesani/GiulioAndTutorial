"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _QueueManager_instances, _QueueManager_voiceEventHandler, _QueueManager_handleSongFinish, _QueueManager_handlePlayingError, _QueueManager_emitPlaySong;
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueManager = void 0;
const _1 = require(".");
const __1 = require("../..");
/**
 * Queue manager
 * @extends BaseManager
 */
class QueueManager extends _1.BaseManager {
    constructor() {
        super(...arguments);
        _QueueManager_instances.add(this);
    }
    /**
     * Collection of {@link Queue}.
     * @name QueueManager#collection
     * @type {Discord.Collection<string, Queue>}
     */
    /**
     * Create a {@link Queue}
     * @private
     * @param {Discord.BaseGuildVoiceChannel} channel A voice channel
     * @param {Song|Song[]} song First song
     * @param {Discord.BaseGuildTextChannel} textChannel Default text channel
     * @returns {Promise<Queue|true>} Returns `true` if encounter an error
     */
    async create(channel, song, textChannel) {
        if (this.has(channel.guild.id))
            throw new __1.DisTubeError("QUEUE_EXIST");
        const voice = this.voices.create(channel);
        const queue = new __1.Queue(this.distube, voice, song, textChannel);
        await queue.taskQueue.queuing();
        try {
            await voice.join();
            __classPrivateFieldGet(this, _QueueManager_instances, "m", _QueueManager_voiceEventHandler).call(this, queue);
            this.add(queue.id, queue);
            this.emit("initQueue", queue);
            const err = await this.playSong(queue);
            return err || queue;
        }
        finally {
            queue.taskQueue.resolve();
        }
    }
    /**
     * Play a song on voice connection
     * @private
     * @param {Queue} queue The guild queue
     * @returns {Promise<boolean>} error?
     */
    async playSong(queue) {
        if (!queue)
            return true;
        if (!queue.songs.length) {
            queue.stop();
            return true;
        }
        if (queue.stopped)
            return false;
        const song = queue.songs[0];
        try {
            const { url, source, formats, streamURL } = song;
            if (source === "youtube" && !formats)
                song._patchYouTube(await this.handler.getYouTubeInfo(url));
            if (source !== "youtube" && !streamURL) {
                for (const plugin of [...this.distube.extractorPlugins, ...this.distube.customPlugins]) {
                    if (await plugin.validate(url)) {
                        const info = [plugin.getStreamURL(url), plugin.getRelatedSongs(url)];
                        const result = await Promise.all(info);
                        song.streamURL = result[0];
                        song.related = result[1];
                        break;
                    }
                }
            }
            const stream = this.handler.createStream(queue);
            queue.voice.play(stream);
            song.streamURL = stream.url;
            if (queue.stopped)
                queue.stop();
            else if (queue.paused)
                queue.voice.pause();
            return false;
        }
        catch (e) {
            __classPrivateFieldGet(this, _QueueManager_instances, "m", _QueueManager_handlePlayingError).call(this, queue, e);
            return true;
        }
    }
}
exports.QueueManager = QueueManager;
_QueueManager_instances = new WeakSet(), _QueueManager_voiceEventHandler = function _QueueManager_voiceEventHandler(queue) {
    queue.listeners = {
        disconnect: error => {
            queue.delete();
            this.emit("disconnect", queue);
            if (error)
                this.emitError(error, queue.textChannel);
        },
        error: error => __classPrivateFieldGet(this, _QueueManager_instances, "m", _QueueManager_handlePlayingError).call(this, queue, error),
        finish: () => __classPrivateFieldGet(this, _QueueManager_instances, "m", _QueueManager_handleSongFinish).call(this, queue),
    };
    for (const event of Object.keys(queue.listeners)) {
        queue.voice.on(event, queue.listeners[event]);
    }
}, _QueueManager_handleSongFinish = 
/**
 * Handle the queue when a Song finish
 * @private
 * @param {Queue} queue queue
 * @returns {Promise<void>}
 */
async function _QueueManager_handleSongFinish(queue) {
    this.emit("finishSong", queue, queue.songs[0]);
    await queue.taskQueue.queuing();
    try {
        if (queue.stopped)
            return;
        if (queue.repeatMode === __1.RepeatMode.QUEUE && !queue.prev)
            queue.songs.push(queue.songs[0]);
        if (queue.prev) {
            if (queue.repeatMode === __1.RepeatMode.QUEUE)
                queue.songs.unshift(queue.songs.pop());
            else
                queue.songs.unshift(queue.previousSongs.pop());
        }
        if (queue.songs.length <= 1 && (queue.next || queue.repeatMode === __1.RepeatMode.DISABLED)) {
            if (queue.autoplay) {
                try {
                    await queue.addRelatedSong();
                }
                catch {
                    this.emit("noRelated", queue);
                }
            }
            if (queue.songs.length <= 1) {
                if (this.options.leaveOnFinish)
                    queue.voice.leave();
                if (!queue.autoplay)
                    this.emit("finish", queue);
                queue.delete();
                return;
            }
        }
        const emitPlaySong = __classPrivateFieldGet(this, _QueueManager_instances, "m", _QueueManager_emitPlaySong).call(this, queue);
        if (!queue.prev && (queue.repeatMode !== __1.RepeatMode.SONG || queue.next)) {
            const prev = queue.songs.shift();
            delete prev.formats;
            delete prev.streamURL;
            if (this.options.savePreviousSongs)
                queue.previousSongs.push(prev);
            else
                queue.previousSongs.push({ id: prev.id });
        }
        queue.next = queue.prev = false;
        queue.beginTime = 0;
        const err = await this.playSong(queue);
        if (!err && emitPlaySong)
            this.emit("playSong", queue, queue.songs[0]);
    }
    finally {
        queue.taskQueue.resolve();
    }
}, _QueueManager_handlePlayingError = function _QueueManager_handlePlayingError(queue, error) {
    const song = queue.songs.shift();
    try {
        error.name = "PlayingError";
        error.message = `${error.message}\nId: ${song.id}\nName: ${song.name}`;
    }
    catch { }
    this.emitError(error, queue.textChannel);
    if (queue.songs.length > 0) {
        this.playSong(queue).then(e => {
            if (!e)
                this.emit("playSong", queue, queue.songs[0]);
        });
    }
    else {
        queue.stop();
    }
}, _QueueManager_emitPlaySong = function _QueueManager_emitPlaySong(queue) {
    return (!this.options.emitNewSongOnly ||
        (queue.repeatMode === __1.RepeatMode.SONG && queue.next) ||
        (queue.repeatMode !== __1.RepeatMode.SONG && queue.songs[0]?.id !== queue.songs[1]?.id));
};
//# sourceMappingURL=QueueManager.js.map