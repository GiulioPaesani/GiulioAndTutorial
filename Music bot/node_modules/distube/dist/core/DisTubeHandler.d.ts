import ytdl from "@distube/ytdl-core";
import { DisTubeBase, DisTubeStream } from ".";
import { Playlist, Queue, SearchResult, Song } from "..";
import type { DisTube, OtherSongInfo } from "..";
import type { GuildMember, GuildTextBasedChannel, Message, VoiceBasedChannel } from "discord.js";
/**
 * DisTube's Handler
 * @extends DisTubeBase
 * @private
 */
export declare class DisTubeHandler extends DisTubeBase {
    constructor(distube: DisTube);
    get ytdlOptions(): ytdl.getInfoOptions;
    /**
     * Create a new guild queue
     * @param {Discord.Message|Discord.VoiceChannel|Discord.StageChannel} message A user message | a voice channel
     * @param {Song|Song[]} song Song to play
     * @param {Discord.BaseGuildTextChannel?} textChannel A text channel of the queue
     * @throws {Error}
     * @returns {Promise<Queue|true>} `true` if queue is not generated
     * @deprecated Use {@link QueueManager#create} instead
     */
    createQueue(message: Message<true> | VoiceBasedChannel, song: Song | Song[], textChannel?: GuildTextBasedChannel): Promise<Queue | true>;
    /**
     * @param {string} url url
     * @param {boolean} [basic=false] getBasicInfo?
     * @returns {Promise<ytdl.videoInfo>}
     */
    getYouTubeInfo(url: string, basic?: boolean): Promise<ytdl.videoInfo>;
    /**
     * Resolve a Song
     * @param {string|Song|SearchResult|Playlist} song URL | Search string | {@link Song}
     * @param {Object} [options] Optional options
     * @param {Discord.GuildMember} [options.member] Requested user
     * @param {*} [options.metadata] Metadata
     * @returns {Promise<Song|Playlist|null>} Resolved
     */
    resolveSong(song: string | ytdl.videoInfo | Song | Playlist | SearchResult | OtherSongInfo | ytdl.relatedVideo, options?: {
        member?: GuildMember;
        metadata?: any;
    }): Promise<Song | Playlist>;
    /**
     * Resolve Song[] or url to a Playlist
     * @param {Playlist|Song[]|string} playlist Resolvable playlist
     * @param {Object} options Optional options
     * @param {Discord.GuildMember} [options.member] Requested user
     * @param {string} [options.source="youtube"] Playlist source
     * @param {*} [options.metadata] Metadata
     * @returns {Promise<Playlist>}
     */
    resolvePlaylist(playlist: Playlist | Song[] | string, options?: {
        member?: GuildMember;
        source?: string;
        metadata?: any;
    }): Promise<Playlist>;
    /**
     * Create a custom playlist
     * @returns {Promise<Playlist>}
     * @param {Discord.Message|Discord.GuildMember} message A message from guild channel | A guild member
     * @param {Array<string|Song|SearchResult>} songs Array of url, Song or SearchResult
     * @param {Object} [properties={}] Additional properties such as `name`
     * @param {boolean} [parallel=true] Whether or not fetch the songs in parallel
     * @param {*} [metadata] Metadata
     * @deprecated Use {@link DisTube#createCustomPlaylist} instead
     */
    createCustomPlaylist(message: Message<true> | GuildMember, songs: (string | Song | SearchResult)[], properties?: any, parallel?: boolean, metadata?: any): Promise<Playlist>;
    /**
     * Play / add a playlist
     * @returns {Promise<void>}
     * @param {Discord.BaseGuildVoiceChannel} voice A voice channel
     * @param {Playlist|string} playlist A YouTube playlist url | a Playlist
     * @param {Object} [options] Optional options
     * @param {Discord.BaseGuildTextChannel} [options.textChannel] The default text channel of the queue
     * @param {boolean} [options.skip=false] Skip the playing song (if exists) and play the added playlist instantly
     * @param {boolean} [options.unshift=false] Add the playlist after the playing song if exists
     */
    handlePlaylist(voice: VoiceBasedChannel, playlist: Playlist, options?: {
        textChannel?: GuildTextBasedChannel;
        skip?: boolean;
        position?: number;
    }): Promise<void>;
    /** @deprecated `options.unshift` is deprecated, use `options.position` instead */
    handlePlaylist(voice: VoiceBasedChannel, playlist: Playlist, options?: {
        textChannel?: GuildTextBasedChannel;
        skip?: boolean;
        position?: number;
        unshift?: boolean;
    }): Promise<void>;
    /**
     * Search for a song, fire {@link DisTube#event:error} if not found.
     * @param {Discord.Message} message The original message from an user
     * @param {string} query The query string
     * @returns {Promise<SearchResult?>} Song info
     */
    searchSong(message: Message<true>, query: string): Promise<SearchResult | null>;
    /**
     * Create a message collector for selecting search results.
     *
     * Needed events: {@link DisTube#event:searchResult}, {@link DisTube#event:searchCancel},
     * {@link DisTube#event:searchInvalidAnswer}, {@link DisTube#event:searchDone}.
     * @param {Discord.Message} message The original message from an user
     * @param {Array<SearchResult|Song|Playlist>} results The search results
     * @param {string?} [query] The query string
     * @returns {Promise<SearchResult|Song|Playlist|null>} Selected result
     */
    createSearchMessageCollector<R extends SearchResult | Song | Playlist>(message: Message<true>, results: Array<R>, query?: string): Promise<R | null>;
    /**
     * Create a ytdl stream
     * @param {Queue} queue Queue
     * @returns {DisTubeStream}
     */
    createStream(queue: Queue): DisTubeStream;
}
//# sourceMappingURL=DisTubeHandler.d.ts.map