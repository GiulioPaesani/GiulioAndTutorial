"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SoundCloudPlugin = void 0;
const soundcloud_ts_1 = __importDefault(require("soundcloud.ts"));
const distube_1 = require("distube");
const sc = new soundcloud_ts_1.default();
const isTruthy = (x) => Boolean(x);
const SEARCH_SUPPORT = ["track", "playlist"];
const chunker = (arr, size) => {
    const chunks = [];
    let i = 0;
    while (i < arr.length)
        chunks.push(arr.slice(i, (i += size)));
    return chunks;
};
const resolveTracks = async (tracks) => {
    const unsolved = tracks.splice(tracks.findIndex(t => !t.title));
    const chunks = chunker(unsolved, 50);
    const promises = chunks.map(ts => sc.api.getV2("/tracks", { ids: ts.map(t => t.id).join(",") }));
    const solvedTracks = await Promise.all(promises);
    return tracks.concat(solvedTracks.flat());
};
class SoundCloudPlugin extends distube_1.ExtractorPlugin {
    /**
     * Search for tracks/playlists on SoundCloud
     * @param {string} query String query
     * @param {'track'|'playlist'} [type='track'] type
     * @param {number} [limit=10] limit
     * @returns {Array<Song>|Array<Playlist>}
     */
    static async search(query, type = "track", limit = 10) {
        var _a;
        if (typeof query !== "string")
            throw new distube_1.DisTubeError("INVALID_TYPE", "string", query, "query");
        if (!SEARCH_SUPPORT.includes(type))
            throw new distube_1.DisTubeError("INVALID_TYPE", SEARCH_SUPPORT, type, "type");
        if (typeof limit !== "number" || limit < 1 || Math.floor(limit) !== limit) {
            throw new distube_1.DisTubeError("INVALID_TYPE", "natural number", limit, "limit");
        }
        if (type === "track") {
            const data = await sc.tracks.searchV2({ q: query, limit });
            if (!((_a = data === null || data === void 0 ? void 0 : data.collection) === null || _a === void 0 ? void 0 : _a.length)) {
                throw new distube_1.DisTubeError("SOUNDCLOUD_PLUGIN_NO_RESULT", `Cannot find any "${query}" ${type} on SoundCloud!`);
            }
            return data.collection.map(t => new distube_1.Song(new SoundCloudTrack(t)));
        }
        const data = await sc.playlists.searchV2({ q: query, limit });
        const playlists = data.collection;
        return (await Promise.all(playlists.map(async (p) => {
            var _a;
            const playlist = new SoundCloudPlaylist(p);
            if (!((_a = playlist.tracks) === null || _a === void 0 ? void 0 : _a.length))
                return;
            playlist.songs = (await resolveTracks(playlist.tracks)).map(s => new distube_1.Song(new SoundCloudTrack(s)));
            // eslint-disable-next-line consistent-return
            return new distube_1.Playlist(playlist);
        }))).filter(isTruthy);
    }
    /**
     * Search for tracks/playlists on SoundCloud
     * @param {string} query String query
     * @param {'track'|'playlist'} [type='track'] type
     * @param {number} [limit=10] limit
     * @returns {Array<Song>|Array<Playlist>}
     */
    search(query, type = "track", limit = 10) {
        return SoundCloudPlugin.search(query, type, limit);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async validate(url) {
        return /^https?:\/\/(?:(?:www|m)\.)?soundcloud\.com\/(.*)$/.test(url);
    }
    async resolve(url, options) {
        var _a;
        const opt = { ...options, source: "soundcloud" };
        url = url.replace(/:\/\/(m|www)\./g, "://");
        const data = await sc.resolve.getV2(url, true).catch(() => undefined);
        if (!data || !["track", "playlist"].includes(data.kind)) {
            throw new distube_1.DisTubeError("SOUNDCLOUD_PLUGIN_NOT_SUPPORTED", "Only public links are supported.");
        }
        if (data.kind === "playlist") {
            const playlist = new SoundCloudPlaylist(data);
            if (!((_a = playlist.tracks) === null || _a === void 0 ? void 0 : _a.length))
                throw new distube_1.DisTubeError("SOUNDCLOUD_PLUGIN_EMPTY_PLAYLIST", "Playlist is empty.");
            playlist.songs = (await resolveTracks(playlist.tracks)).map(s => new distube_1.Song(new SoundCloudTrack(s), opt));
            return new distube_1.Playlist(playlist, opt);
        }
        else {
            return new distube_1.Song(new SoundCloudTrack(data), opt);
        }
    }
    async getRelatedSongs(url) {
        const related = await sc.tracks.relatedV2(url, 10);
        return related.filter(t => t.title).map(t => new distube_1.Song(new SoundCloudTrack(t)));
    }
    async getStreamURL(url) {
        const stream = await sc.util.streamLink(url);
        if (!stream) {
            throw new distube_1.DisTubeError("SOUNDCLOUD_PLUGIN_RATE_LIMITED", "Reached SoundCloud rate limits\nSee more: https://developers.soundcloud.com/docs/api/rate-limits#play-requests");
        }
        return stream;
    }
}
exports.SoundCloudPlugin = SoundCloudPlugin;
class SoundCloudTrack {
    constructor(info) {
        var _a, _b;
        this.src = "soundcloud";
        this.id = info.id.toString();
        this.name = info.title;
        this.url = info.permalink_url;
        this.thumbnail = info.artwork_url;
        this.duration = info.duration / 1000;
        this.views = info.playback_count;
        this.reposts = info.reposts_count;
        this.uploader = (_a = info.user) === null || _a === void 0 ? void 0 : _a.username;
        this.uploader_url = (_b = info.user) === null || _b === void 0 ? void 0 : _b.permalink_url;
    }
}
class SoundCloudPlaylist {
    constructor(info) {
        var _a;
        this.source = "soundcloud";
        this.id = info.id;
        this.name = info.title;
        this.url = info.permalink_url;
        this.thumbnail = (_a = info.artwork_url) !== null && _a !== void 0 ? _a : undefined;
        this.tracks = info.tracks;
    }
}
exports.default = SoundCloudPlugin;
//# sourceMappingURL=index.js.map