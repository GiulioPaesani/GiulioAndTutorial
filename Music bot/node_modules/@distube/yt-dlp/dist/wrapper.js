"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.download = exports.json = exports.raw = void 0;
const dargs_1 = __importDefault(require("dargs"));
const execa_1 = __importDefault(require("execa"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const petitio_1 = __importDefault(require("petitio"));
const promises_1 = __importDefault(require("node:fs/promises"));
const env_1 = require("./env");
const makeRequest = async (url) => {
    const response = await (0, petitio_1.default)(url).header({ "user-agent": "distube" }).send();
    if (!response.statusCode)
        throw new Error(`Cannot make requests to '${url}'`);
    if (response.statusCode.toString().startsWith("3"))
        return makeRequest(response.headers.location);
    if (response.statusCode.toString().startsWith("2"))
        return response;
    throw new Error(`${url}\nStatus code ${response.statusCode.toString()}`);
};
const args = (url, flags = {}) => [url].concat((0, dargs_1.default)(flags, { useEquals: false })).filter(Boolean);
const raw = (url, flags, options) => (0, execa_1.default)(env_1.YTDLP_PATH, args(url, flags), options);
exports.raw = raw;
const json = (url, flags, options) => (0, exports.raw)(url, flags, options).then(({ stdout }) => JSON.parse(stdout));
exports.json = json;
const binContentTypes = ["binary/octet-stream", "application/octet-stream", "application/x-binary"];
const getBinary = async (url) => {
    const response = await makeRequest(url);
    const contentType = response.headers["content-type"];
    if (binContentTypes.includes(contentType))
        return { buffer: response.body, version: "N/A" };
    const [{ assets, tag_name }] = response.json();
    const { browser_download_url } = assets.find(({ name }) => name === env_1.YTDLP_FILENAME);
    return makeRequest(browser_download_url).then(r => ({
        buffer: r.body,
        version: typeof tag_name === "string" ? tag_name : "N/A",
    }));
};
const download = () => Promise.all([getBinary(env_1.YTDLP_URL), (0, mkdirp_1.default)(env_1.YTDLP_DIR)]).then(([{ buffer, version }]) => {
    promises_1.default.writeFile(env_1.YTDLP_PATH, buffer, { mode: 493 });
    return version;
});
exports.download = download;
//# sourceMappingURL=wrapper.js.map